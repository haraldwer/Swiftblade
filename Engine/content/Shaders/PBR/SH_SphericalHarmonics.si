
// https://www.ppsloan.org/publications/StupidSH36.pdf
// https://www.ppsloan.org/publications/SHJCGT.pdf

// This is the spherical harmonics basis
void EvalSHBasis(vec3 d, out float sh[9])
{
    float x = d.x;
    float y = d.y;
    float z = d.z;

    sh[0] =  0.282095;

    sh[1] =  0.488603 * y;
    sh[2] =  0.488603 * z;
    sh[3] =  0.488603 * x;

    sh[4] =  1.092548 * x * y;
    sh[5] =  1.092548 * y * z;
    sh[6] =  0.315392 * (3.0 * z * z - 1.0);
    sh[7] =  1.092548 * x * z;
    sh[8] =  0.546274 * (x * x - y * y);
}

// The angle that this pixel covers
float TexelSolidAngle(vec2 uv, int size)
{
    // uv in [-1,1] range
    float x = uv.x;
    float y = uv.y;

    float invRes = 2.0 / float(size);
    float x0 = x - invRes * 0.5;
    float y0 = y - invRes * 0.5;
    float x1 = x + invRes * 0.5;
    float y1 = y + invRes * 0.5;

    float f00 = 1.0 / pow(x0*x0 + y0*y0 + 1.0, 1.5);
    float f10 = 1.0 / pow(x1*x1 + y0*y0 + 1.0, 1.5);
    float f01 = 1.0 / pow(x0*x0 + y1*y1 + 1.0, 1.5);
    float f11 = 1.0 / pow(x1*x1 + y1*y1 + 1.0, 1.5);

    return (f00 + f10 + f01 + f11) * (invRes * invRes) * 0.25;
}

// TODO: SSAO Bent normals - Save the ray direction so that you know which way the surface was blocked, use this when sampling irradiance

