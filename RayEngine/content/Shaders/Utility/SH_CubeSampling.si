

// Atlas cube sampling

vec3 GetFlatCubeUV(vec3 InDir)
{
    vec3 absDir = abs(InDir);
    float a = max(max(absDir.x, absDir.y), absDir.z);
    vec3 n = InDir / (a + 1e-6);

    bool useX = absDir.x >= absDir.y && absDir.x >= absDir.z;
    bool useY = absDir.y >  absDir.z && absDir.y >  absDir.x;
    bool useZ = !useX && !useY;

    float signX = step(0.0, n.x) * 2.0 - 1.0; // +1 or -1
    float signY = step(0.0, n.y) * 2.0 - 1.0;
    float signZ = step(0.0, n.z) * 2.0 - 1.0;

    // Compute UV for each axis
    vec2 uvXpos = vec2(-n.y, n.z);
    vec2 uvXneg = vec2(n.y, n.z);
    vec2 uvYpos = vec2(n.x, n.z);
    vec2 uvYneg = vec2(n.x, -n.z);
    vec2 uvZpos = vec2(n.x, -n.y);
    vec2 uvZneg = vec2(-n.x, -n.y);

    // Select without branching
    vec2 uvX = mix(uvXneg, uvXpos, step(0.0, n.x));
    vec2 uvY = mix(uvYneg, uvYpos, step(0.0, n.y));
    vec2 uvZ = mix(uvZneg, uvZpos, step(0.0, n.z));

    vec2 uv = mix(mix(uvZ, uvY, float(useY)), uvX, float(useX));
    float side =
    mix(mix(5.0 + step(0.0, n.z) * -1.0,
    3.0 - step(0.0, n.y) * 1.0,
    float(useY)),
    1.0 - step(0.0, n.x) * 1.0,
    float(useX));

    uv = (uv + 1.0) * 0.5;
    uv = clamp(uv, 0.0, 1.0);
    return vec3(uv, side);
}

vec2 GetCubeAtlasUV(vec2 InFaceTexel, vec4 InRect, vec3 InDir)
{
    vec3 uv = GetFlatCubeUV(InDir);

    vec2 faceUV = InRect.zw * uv.xy;
    faceUV = clamp(faceUV, InFaceTexel, InRect.zw - InFaceTexel);
    faceUV += InRect.xy;
    faceUV.x += InRect.z * uv.z; // Add face index

    float fl = floor(faceUV.x);
    faceUV.y += fl * InRect.w;
    faceUV.x -= fl;
    return faceUV;
}

vec4 SampleCubeAtlas(sampler2D InAtlas, vec2 InFaceTexel, vec4 InRect, vec3 InDir)
{
    return texture(InAtlas, GetCubeAtlasUV(InFaceTexel, InRect, InDir));
}

vec4 SampleCubeAtlasMip(sampler2D InAtlas, vec2 InFaceTexel, vec4 InRect, vec3 InDir, int InMip)
{
    return texture(InAtlas, GetCubeAtlasUV(InFaceTexel, InRect, InDir));
}

// Spheres and octahedrons
// https://gamedev.stackexchange.com/questions/169508/octahedral-impostors-octahedral-mapping

vec3 UVtoOctahedronDir(vec2 InUV)
{
    // Unpack the 0...1 range to the -1...1 unit square.
    vec2 uv = InUV * 2.0f - 1.0f;
    vec3 position = vec3(uv.x, 0.0f, uv.y);

    // "Lift" the middle of the square to +1 z, and let it fall off linearly
    // to z = 0 along the Manhattan metric diamond (absolute.x + absolute.y == 1),
    // and to z = -1 at the corners where position.x and .y are both = +-1.
    vec2 absolute = abs(position.xy);
    position.y = 1.0f - absolute.x - absolute.y;

    // "Tuck in" the corners by reflecting the xy position along the line y = 1 - x
    // (in quadrant 1), and its mirrored image in the other quadrants.
    if(position.y < 0.0f)
    {
        position.xz = sign(position.xz) * vec2(1.0f - absolute.y, 1.0f - absolute.x);
    }

    return position;
}

vec2 OctahedronDirToUV(vec3 InDir)
{
    vec3 octant = sign(InDir);

    // Scale the vector so |x| + |y| + |z| = 1 (surface of octahedron).
    float sum = dot(InDir, octant);
    vec3 octahedron = InDir / sum;

    // "Untuck" the corners using the same reflection across the diagonal as before.
    // (A reflection is its own inverse transformation).
    if(octahedron.y < 0.0f)
    {
        vec3 absolute = abs(octahedron);
        octahedron.xz = octant.xz * vec2(1.0f - absolute.z, 1.0f - absolute.x);
    }

    return octahedron.xy * 0.5f + 0.5f;
}

vec4 SampleOct(sampler2D InSampler, vec3 InDir)
{
    return texture(InSampler, OctahedronDirToUV(InDir));
}

