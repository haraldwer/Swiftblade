#include "Shaders/Uniforms/SH_FrameUniforms.si"
#include "Shaders/Uniforms/SH_TexUniforms.si"
#include "Shaders/Utility/SH_Random.si"
#include "Shaders/Utility/SH_Utility.si"
#include "Shaders/Utility/SH_DeferredID.si"

in vec2 TexCoord;
out vec4 Output;

const int ITERATIONS = 16;
const float INTENSITY = 1;
const float LERP_SPEED = 0.2;
const float DEPTH_THRESHOLD = 2;
const float SAMPLE_DIST = 5;
const float LIKELY_DIR_MUL = 1.3;

vec3 SSAOPosition(vec2 uv)
{
     return SampleWorldPos(uv).xyz;
}

vec3 SSAONormal(vec2 uv)
{
     return SampleNormal(uv);
}

float SSAOIteration(vec2 InCoord, vec3 InStartPosition, vec3 InStartNormal)
{
     vec3 position = SSAOPosition(InCoord);
     
     // Pixel distance
     vec3 difference = position - InStartPosition;
     float distance = length(difference);
     float distanceFade = max(0, 1 - distance / SAMPLE_DIST);
     
     // Pixel direction to start compared to normal
     vec3 surfaceDir = difference / distance;
     float surfaceDot = max(0, dot(surfaceDir, InStartNormal));
     
     // Surface normal compared to start normal
     // Skipping this because the results werent that good
     //vec3 normal = SSAONormal(InCoord);
     float normalDot = 0;// 1 - max(0, dot(normal, InStartNormal));
     
     return max(surfaceDot, normalDot) * distanceFade;
}

float FrameSSAO(vec3 InStartPos)
{
     vec3 startNormal = SSAONormal(TexCoord);
     vec3 cameraDir = normalize(InStartPos - CameraPosition);
     
     // What direction is the most likely? 
     vec3 likelyDir = reflect(cameraDir, startNormal);
     
     // To coord
     vec3 refScreenPos = (ViewProj * vec4(InStartPos, 1)).xyz;
     vec3 screenPos = (ViewProj * vec4(InStartPos + likelyDir * LIKELY_DIR_MUL, 1)).xyz;
     vec2 likelyCoordDir = (screenPos.xy - refScreenPos.xy) / 2;
     float likelyDist = length(likelyCoordDir);
     
     float ao = 0;
     for (int i = 0; i < ITERATIONS; i++)
     {
          // Randomize dir
          vec2 randDir = (Random2(Random2(i + Time) + TexCoord) * 2 - vec2(1)) * likelyDist;
          float randDot = dot(randDir, likelyCoordDir);
          
          // Weight towards likelyDir
          vec2 dir = randDir * randDot;
          vec2 coord = clamp(TexCoord + dir, 0.0001, 0.9999);
          ao += SSAOIteration(coord, InStartPos, startNormal);
     }
     return ao / ITERATIONS;
}

vec4 BlurAccumulation(vec2 InCoord)
{
     vec2 pixelScale = vec2(1.0f) / Resolution;
     vec3 offsets[8] = vec3[](
          vec3( 1, 1, 0.72),
          vec3(-1, 1, 0.72),
          vec3( 1,-1, 0.72),
          vec3(-1,-1, 0.72),
          
          vec3( 1, 0, 1.0),
          vec3( 0, 1, 1.0),
          vec3(-1, 0, 1.0),
          vec3( 0,-1, 1.0)
     );
     
     float acc = 0.0;
     float weight = 0.0;
     for (int j = 0; j < 8; ++j)
     {
          vec3 off = offsets[j];
          vec2 coord = Saturate(InCoord + off.xy * pixelScale);
          vec4 ao = texture(TexAO, coord);
          acc += ao.g * off.z;
          acc += ao.b * off.z;
          acc += ao.a * off.z;
          weight += off.z * 3;
     }
     
     vec4 prevAO = texture(TexAO, InCoord);
     acc += (prevAO.g + prevAO.b + prevAO.a) * 2;
     weight += 2 * 3;
     
     return vec4(prevAO.rgb, acc / weight); 
}

void main()
{
     Output = vec4(vec3(0.0), 0.0);

     if (!CheckID(TexCoord, 0)) // Exclude skybox
          return;
     
     vec4 position = SampleWorldPos(TexCoord);
     vec3 velocity = texture(TexData, TexCoord).rgb;
     
     // 1. Sample current
     float newSample = FrameSSAO(position.xyz);
     
     // 2. Blur and sample previous 
     vec4 blur = vec4(0); // r = prevValue, gb = prevSamples, a = blurred
     vec2 prevCoord = TexCoord - velocity.xy / 2;
     if ( prevCoord.x < 1.0 && prevCoord.x > 0.0 &&
          prevCoord.y < 1.0 && prevCoord.y > 0.0)
     {
          vec4 prevPos = SampleWorldPos(prevCoord);
          float depthDiff = abs(position.w - prevPos.w);
          if (depthDiff < DEPTH_THRESHOLD)
               blur = BlurAccumulation(prevCoord);
     }
     
     // 3. Lerp towards blur
     blur.r = mix(blur.r, blur.a * INTENSITY, LERP_SPEED);
     
     // 4. Output blur
     Output.r = blur.r;
     
     // 5. Update previous
     Output.g = newSample;
     Output.ba = blur.gb; // discard oldest sample
}
