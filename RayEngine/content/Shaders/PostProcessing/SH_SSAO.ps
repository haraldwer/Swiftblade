#include "Shaders/Uniforms/SH_FrameUniforms.si"
#include "Shaders/Uniforms/SH_TexUniforms.si"
#include "Shaders/Utility/SH_Random.si"
#include "Shaders/Utility/SH_Utility.si"
#include "Shaders/Utility/SH_DeferredID.si"

in vec2 TexCoord;
out vec4 Output;

const int ITERATIONS = 4;
const float INTENSITY = 0.3;
const float LERP_SPEED = 0.4;
const float SAMPLE_MAX_MIX = 0.2;

const float SCALE = 0.05;
const float INTERP_DEPTH_THRESHOLD_MUL = 0.1;
const float DIR_RANDOMNESS = 0.25;

vec3 SSAOPosition(vec2 uv)
{
     return SampleWorldPos(uv).xyz;
}

vec3 SSAONormal(vec2 uv)
{
     return SampleNormal(uv);
}

float SSAOIteration(vec2 InCoord, vec3 InStartPosition, vec3 InStartNormal)
{
     vec3 position = SSAOPosition(InCoord);
     
     // Pixel distance
     vec3 difference = position - InStartPosition;
     float distance = length(difference);
     
     // Pixel direction to start compared to normal
     vec3 surfaceDir = difference / distance; 
     return max(0, dot(surfaceDir, InStartNormal));
}

float FrameSSAO(vec3 InStartPos, vec3 InCamDir)
{
     vec3 startNormal = SSAONormal(TexCoord);
     float rand = Random(Time + Random(TexCoord));
     
     // What direction is the most likely?
     vec3 likelyDir = reflect(InCamDir, startNormal);
     vec3 randomDir = Random3(vec3(TexCoord, rand)) * 2 - vec3(1);
     likelyDir += randomDir * DIR_RANDOMNESS; // Plus some randomness
     
     // To coord
     vec3 refScreenPos = (ViewProj * vec4(InStartPos, 1)).xyz;
     vec3 screenPos = (ViewProj * vec4(InStartPos + likelyDir, 1)).xyz;
     vec2 likelyCoordDir = (screenPos.xy - refScreenPos.xy) / 2;
     
     // Normalize, keep sign
     float likelyDist = length(likelyCoordDir);
     likelyCoordDir /= likelyDist;

     float ao = 0;
     float aoMax = 0;
     for (int i = 0; i < ITERATIONS; i++)
     {
          // Randomize dir
          vec2 randDir = (Random2(vec2(rand, i)) * 2 - vec2(1));
          float randDot = dot(randDir, likelyCoordDir);
          vec2 dir = randDir * randDot * SCALE;
          vec2 coord = clamp(TexCoord + dir, 0.0001, 0.9999);
          float value = SSAOIteration(coord, InStartPos, startNormal);
          ao += value;
          aoMax = max(aoMax, value);
     }
     return mix(ao / ITERATIONS, aoMax, SAMPLE_MAX_MIX);
}

// acc + weight
vec2 BlurSamplePoint(sampler2D InTex, vec2 InCoord, float InWeight)
{
     vec4 ao = texture(InTex, Saturate(InCoord));
     float acc = (ao.g + ao.b + ao.a) * InWeight;
     return vec2(acc, InWeight * 3);
}

vec2 BlurSample(sampler2D InTex, vec2 InCoord)
{
     //return vec2(0);
     vec2 pixelScale = vec2(1) / Resolution;
     
     float middleScale = 1;
     float farScale = 1;
     float middleWeight = 0.8;
     float farWeight = 0.5;

     vec2 edgeOff[4] = vec2[](
          vec2(1,1),
          vec2(1,-1),
          vec2(-1,1),
          vec2(-1,-1)
     );
     vec2 middleOff[4] = vec2[](
          vec2(1, 0),
          vec2(-1,0),
          vec2(0, 1),
          vec2(0,-1)
     );

     vec2 result = vec2(0);
     for (int i = 0; i < 4; i++)
          result += BlurSamplePoint(InTex, InCoord + middleOff[i] * pixelScale * middleScale, middleWeight);
     for (int i = 0; i < 4; i++)
          result += BlurSamplePoint(InTex, InCoord + edgeOff[i] * pixelScale * farScale, farWeight);
     return result;
}

vec4 BlurAccumulation(vec2 InCoord)
{
     vec4 prevAO = texture(TexAO, InCoord);
     vec2 result = BlurSample(TexAO, InCoord);
     result.x += (prevAO.g + prevAO.b + prevAO.a);
     result.y += 3;
     return vec4(prevAO.rgb, result.x / result.y); 
}

void main()
{
     Output = vec4(vec3(0.0), 0.0);

     if (!CheckID(TexCoord, 0)) // Exclude skybox
          return;
     
     vec4 position = SampleWorldPos(TexCoord);
     vec3 velocity = texture(TexData, TexCoord).rgb;
     
     // Camera distance
     vec3 cameraDiff = position.xyz - CameraPosition;
     float cameraDist = length(cameraDiff);
     vec3 cameraDir = cameraDiff / cameraDist;
     
     // 1. Sample current
     float newSample = FrameSSAO(position.xyz, cameraDir);
     
     // 2. Blur and sample previous 
     vec4 blur = vec4(0); // r = prevValue, gb = prevSamples, a = blurred
     vec2 prevCoord = TexCoord - velocity.xy / 2;
     if ( prevCoord.x < 1.0 && prevCoord.x > 0.0 &&
          prevCoord.y < 1.0 && prevCoord.y > 0.0)
     {
          vec4 prevPos = SampleWorldPos(prevCoord);
          float depthDiff = abs(position.w - prevPos.w);
          if (depthDiff < cameraDist * INTERP_DEPTH_THRESHOLD_MUL)
               blur = BlurAccumulation(prevCoord);
     }
     
     blur.a = max(blur.a, newSample);
     
     // 3. Lerp towards blur
     blur.r = mix(blur.r, blur.a * INTENSITY, LERP_SPEED);
     
     // 4. Output blur
     Output.r = blur.r;
     
     // 5. Update previous
     Output.g = newSample; // First use of new sample?
     Output.ba = blur.gb; // discard oldest sample
}
