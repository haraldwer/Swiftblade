#include "Shaders/Uniforms/SH_FrameUniforms.si"
#include "Shaders/Uniforms/SH_TexUniforms.si"
#include "Shaders/Uniforms/SH_DeferredOut.si"
#include "Shaders/Utility/SH_DeferredID.si"
#include "Shaders/Utility/SH_Utility.si"

in vec2 TexCoord;
in vec2 RectCoord;
out vec3 Output;

const float BUMP_SCALE = 0.1;
const float BUMP_MAX_DIST = 1.0;

vec3 GetSurfaceDirection(vec2 InCoord, vec2 InDir, vec3 InCamPos, vec3 InNormal, float InHeight)
{
    vec2 texel = vec2(1) / Resolution;
    vec2 rightCoord = InCoord + texel * InDir;
    vec2 leftCoord = InCoord - texel * InDir;

    vec3 orgPos = InCamPos.xyz - InNormal * InHeight * BUMP_SCALE;
    
    float rightHeight = texture(TexData, rightCoord).z;
    float leftHeight = texture(TexData, leftCoord).z;
    vec3 rightPos = texture(TexPosition, rightCoord).xyz;
    vec3 leftPos = texture(TexPosition, leftCoord).xyz;
    rightPos -= InNormal * rightHeight * BUMP_SCALE;
    leftPos -= InNormal * leftHeight * BUMP_SCALE;
    
    vec3 rightDiff = orgPos - rightPos;
    vec3 leftDiff = leftPos - orgPos;
    float rightDist = max(0, 1 - length(rightDiff) / BUMP_MAX_DIST);
    float leftDist = max(0, 1 - length(leftDiff) / BUMP_MAX_DIST);
    
    return normalize((rightDiff * rightDist + leftDiff * leftDist + InNormal * 0.001) / (rightDist + leftDist + 0.001));
}

vec3 BumpNormal(vec2 InCoord, vec4 InCamPos, vec3 InNormal, float InHeight)
{
    vec3 right = GetSurfaceDirection(InCoord, vec2(1, 0), InCamPos.xyz, InNormal, InHeight);
    vec3 up = GetSurfaceDirection(InCoord, vec2(0, 1), InCamPos.xyz, InNormal, InHeight);
    vec3 forward = cross(right, up);
    return forward;
}

void main()
{
    // Copy data
    OutPosition = texture(TexPosition, TexCoord);
    OutNormal = texture(TexNormal, TexCoord);
    OutColor = texture(TexColor, TexCoord);
    OutData = texture(TexData, TexCoord).xyz;

    if (!CheckID(TexCoord, 0)) // Exclude skybox
        return;
    
    OutNormal.xyz = BumpNormal(TexCoord, OutPosition, OutNormal.xyz, OutData.z);
}