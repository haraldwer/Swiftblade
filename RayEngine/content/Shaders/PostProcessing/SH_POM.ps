#include "Shaders/Uniforms/SH_FrameUniforms.si"
#include "Shaders/Uniforms/SH_TexUniforms.si"
#include "Shaders/Uniforms/SH_DeferredOut.si"
#include "Shaders/Utility/SH_DeferredID.si"
#include "Shaders/Utility/SH_Utility.si"

in vec2 TexCoord;
in vec2 RectCoord;
out vec3 Output;

const int MIN_PARALLAX_SAMPLES = 2;
const int MAX_PARALLAX_SAMPLES = 16;
const float PARALLAX_SCALE = 0.001;

vec3 GetSurfaceDirection(vec2 InCoord, vec2 InDir, vec3 InCamPos)
{
    vec2 texel = vec2(1) / Resolution;
    vec2 rightCoord = InCoord + texel * InDir;
    vec2 leftCoord = InCoord - texel * InDir;

    vec3 rightPos = texture(TexPosition, rightCoord).xyz;
    vec3 leftPos = texture(TexPosition, leftCoord).xyz;
    vec3 rightDiff = InCamPos - rightPos;
    vec3 leftDiff = leftPos - InCamPos;
    float rightDist = max(0, 1 - length(rightDiff) * 10);
    float leftDist = max(0, 1 - length(leftDiff) * 10);

    return normalize(rightDiff * rightDist + leftDiff * leftDist);
}

struct ParallaxOffset
{
    vec3 worldPos;
    vec3 normal;
    vec2 uv;
};

ParallaxOffset ParallaxOcclusion(float InHeight, vec4 InPos, vec3 InNormal)
{
    // Get surface directions
    vec3 worldPos = InPos.xyz + CameraPosition;
    vec3 right = GetSurfaceDirection(TexCoord, vec2(1, 0), InPos.xyz);
    vec3 up = GetSurfaceDirection(TexCoord, vec2(0, 1), InPos.xyz);
    vec3 forward = cross(right, up);
    
    // First, get the direction
    float camDist = length(InPos.xyz);
    float camLerp = clamp((camDist - NearFar.x) / NearFar.y, 0.01, 1);
    vec3 camDir = -normalize(InPos.xyz);
    mat3 tanMat = mat3(-up, right, forward);
    vec3 viewDir = camDir * tanMat;
    vec3 viewDirTS = viewDir.yxz;
    vec2 maxOffset = vec2(viewDirTS.x, -viewDirTS.y) * PARALLAX_SCALE / camLerp;
    
    float surfaceDot = max(0, dot(InNormal, camDir));
    float sampleLerp = mix(MIN_PARALLAX_SAMPLES, MAX_PARALLAX_SAMPLES, 1 - surfaceDot);
    int samples = int(sampleLerp); 
    
    vec2 step = maxOffset / samples;
    float heightStep = 1.0 / samples;

    vec2 coord = TexCoord;
    float surfaceHeight = 0.0;
    float depth = InPos.w;
    vec3 normal = InNormal;
    
    for (int i = 1; i < samples; i++)
    {
        vec2 prevCoord = coord;
        float prevDepth = depth;
        
        coord = clamp(TexCoord + step * i, 0.001, 0.999);
        depth = texture(TexPosition, coord).w;
        float depthDiff = prevDepth - depth;
        //if (depthDiff > 0.1)
        //    break;
        
        float rayHeight = heightStep * i;
        float prevSurfaceHeight = surfaceHeight;
        vec3 prevNormal = normal;
        
        surfaceHeight = texture(TexData, coord).z;
        normal = texture(TexNormal, coord).xyz;
        
        float nd = max(0, dot(normal, InNormal));
        float intersectDiff = surfaceHeight * nd - rayHeight;
        if (intersectDiff < 0)
        {
            float prevNd = max(0, dot(prevNormal, InNormal));
            float prevRayHeight = heightStep * (i - 1);
            float prevDiff = prevSurfaceHeight * prevNd - prevRayHeight;
            float lerp = prevDiff / (prevDiff - intersectDiff);
            
            vec3 prevPos = SampleWorldPos(prevCoord).xyz - up * prevSurfaceHeight * PARALLAX_SCALE; 
            vec3 intersectPos = SampleWorldPos(coord).xyz - up * surfaceHeight * PARALLAX_SCALE;
            
            vec3 tangent = normalize(prevPos - intersectPos);
            vec3 bitangent = cross(tangent, normal);
            vec3 surfaceNormal = cross(bitangent, tangent);
            
            ParallaxOffset off;
            off.uv = mix(coord, prevCoord, lerp);
            off.worldPos = mix(intersectPos, prevPos, lerp);
            off.normal = normalize(mix(normal, surfaceNormal, 0.9));
            
            return off;
        }
    }

    // TODO: Lerp result
    
    ParallaxOffset offset;
    offset.uv = coord;
    offset.worldPos = SampleWorldPos(coord).xyz - up * surfaceHeight * PARALLAX_SCALE;
    offset.normal = normal;
    return offset; 
}

void main()
{
    // Copy data
    OutPosition = texture(TexPosition, TexCoord);
    OutNormal = texture(TexNormal, TexCoord);
    OutData = texture(TexData, TexCoord);
    
    if (!CheckID(TexCoord, 0)) // Exclude skybox
        return;    
    
    // Parallax occlusion mapping
    ParallaxOffset offset = ParallaxOcclusion(OutData.z, OutPosition.xyzw, OutNormal.xyz);
    
    // Update buffer values
    OutPosition.xyz = offset.worldPos - CameraPosition;
    OutNormal.xyz = offset.normal;
    OutNormal.a = texture(TexNormal, offset.uv).a;
    OutData = texture(TexData, offset.uv).xyz;
}