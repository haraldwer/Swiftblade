
// https://www.ppsloan.org/publications/StupidSH36.pdf
// https://www.ppsloan.org/publications/SHJCGT.pdf

// This is the spherical harmonics basis
void EvalSHBasis(vec3 d, out float sh[9])
{
    float x = d.x;
    float y = d.y;
    float z = d.z;

    sh[0] =  0.282095;

    sh[1] =  0.488603 * y;
    sh[2] =  0.488603 * z;
    sh[3] =  0.488603 * x;

    sh[4] =  1.092548 * x * y;
    sh[5] =  1.092548 * y * z;
    sh[6] =  0.315392 * (3.0 * z * z - 1.0);
    sh[7] =  1.092548 * x * z;
    sh[8] =  0.546274 * (x * x - y * y);
}

// The angle that this pixel covers
float TexelSolidAngle(vec2 uv, int size)
{
    // uv in [-1,1] range
    float x = uv.x;
    float y = uv.y;

    float invRes = 2.0 / float(size);
    float x0 = x - invRes * 0.5;
    float y0 = y - invRes * 0.5;
    float x1 = x + invRes * 0.5;
    float y1 = y + invRes * 0.5;

    float f00 = 1.0 / pow(x0*x0 + y0*y0 + 1.0, 1.5);
    float f10 = 1.0 / pow(x1*x1 + y0*y0 + 1.0, 1.5);
    float f01 = 1.0 / pow(x0*x0 + y1*y1 + 1.0, 1.5);
    float f11 = 1.0 / pow(x1*x1 + y1*y1 + 1.0, 1.5);

    return (f00 + f10 + f01 + f11) * (invRes * invRes) * 0.25;
}

// Accumulates the SH values from a cubemap
// Maybe I can do this per face, so that only one render pass is required?
// And blend the radiance textures?
void AccumulateCubemapToSH(samplerCube InTexEnv, int InFaceRes, int InFaceIndex, int InBandIndex, out vec4 OutRadiance[9])
{
    OutRadiance[InBandIndex] = vec4(0);

    for(int y=0; y<InFaceRes; y++)
    for(int x=0; x<InFaceRes; x++)
    {
        vec2 uv = (vec2(x,y) + 0.5) / InFaceRes * 2.0 - 1.0;
        vec3 dir = CubemapUVToDir(InFaceIndex, uv);

        float sa = TexelSolidAngle(uv, InFaceRes);
        vec4 pixel = texture(InTexEnv, dir);
        vec3 radiance = pixel.rgb;
        float depth = pixel.a;

        float Y[9];
        EvalSHBasis(dir, Y);
        
        float w = Y[InBandIndex] * sa;
        OutRadiance[InBandIndex].rgb += radiance * w;
        OutRadiance[InBandIndex].a += depth * w;
    }
}

// Sample radiance + irradiance + depth
void SampleSH(vec3 InNormal, vec4 InCoeff[9], out vec3 OutRadiance, out vec3 OutIrradiance, out float OutDepth)
{
    float basis[9];
    EvalSHBasis(InNormal, basis);

    float y0 = basis[i];
    vec3 shrgb0 = InCoeff[i].rgb;
    float sha0 = InCoeff[i].a;
    OutRadiance = shrgb0 * y0;
    OutDepth = sha0 * y0;
    OutIrradiance = shrgb0 * PI;
    
    float scaleL1 = 2.0 * PI / 3.0;
    for (int i = 1; i <= 3; ++i)
    {
        float yi = basis[i];
        vec3 shrgb = InCoeff[i].rgb;
        float sha = InCoeff[i].a;

        OutRadiance += shrgb * yi;
        OutDepth += sha * yi;
        OutIrradiance += shrgb * yi * scaleL1;
    }

    float scaleL2 = PI / 4.0;
    for (int i = 4; i <= 8; ++i)
    {
        float yi = basis[i];
        vec3 shrgb = InCoeff[i].rgb;
        float sha = InCoeff[i].a;

        OutRadiance += shrgb * yi;
        OutDepth += sha * yi;
        OutIrradiance += shrgb * yi * scaleL2;
    }
}

// TODO: SSAO Bent normals - Save the ray direction so that you know which way the surface was blocked, use this when sampling irradiance

