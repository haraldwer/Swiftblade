#include "Shaders/Uniforms/SH_FrameUniforms.si"
#include "Shaders/Uniforms/SH_TexUniforms.si"
#include "Shaders/Utility/SH_Utility.si"
#include "Shaders/Utility/SH_DeferredID.si"

#include "Shaders/Lights/SH_Shadows.si"
#include "Shaders/Lights/SH_SSShadows.si"
#include "Shaders/PBR/SH_PBR_Light.si"

const int MAX_LIGHTS = 10;

uniform vec4 Positions[MAX_LIGHTS]; // + ranges
uniform vec4 Directions[MAX_LIGHTS]; // + cones
uniform vec4 Colors[MAX_LIGHTS]; // + intensity

uniform vec4 ShadowPositions[MAX_LIGHTS]; // + timestamps
uniform vec4 ShadowRects[MAX_LIGHTS];

uniform sampler2D TexShadow;
uniform vec2 FaceTexel;
uniform int Lights;

in vec2 TexCoord;
out vec4 Output;

float Godrays(vec4 InWorldPos, vec3 InToLight)
{
    return 0.0;
}

void main()
{
    Output = vec4(0);
    if (!CheckID(TexCoord, 0)) // Exclude skybox
        return;
    
    vec4 worldPos = SampleWorldPos(TexCoord);
    vec3 normal = SampleNormal(TexCoord);
    
    for (int i = 0; i < Lights; i++)
    {   
        vec3 position = Positions[i].xyz;
        vec3 toLight = position - worldPos.xyz;
        float lightDistSqr = SquaredLength(toLight);
        
        float range = Positions[i].w;
        if (lightDistSqr > range * range)
            continue;
        
        float lightDist = sqrt(lightDistSqr);
        vec3 toLightDir = toLight / lightDist;
        float d = dot(toLightDir, normal);
        if (d < -0.1)
            continue;
        
        vec3 shadowPos = ShadowPositions[i].xyz;
        vec4 shadowRect = ShadowRects[i];
        vec3 toLightShadow = shadowPos - worldPos.xyz;
        float shadow = Shadow(toLightShadow, TexShadow, TexCoord, FaceTexel, shadowRect, range);
        if (shadow < 0.001f)
            continue;
        //shadow = min(shadow, ScreenSpaceShadow(worldPos, position));
        //if (shadow < 0.001f)
        //    continue;
        
        float ao = 1.0 - texture(TexAO, TexCoord).x;
        vec3 albedo = vec3(1);
        vec3 surface = vec3(1, 1, 0);
        vec3 color = Colors[i].xyz * Colors[i].w;
        
        vec3 light = PBRLight(worldPos.xyz, normal, albedo, surface, position, color);
        
        Output.rgb += light;
        Output.a = 1;
    }
}
