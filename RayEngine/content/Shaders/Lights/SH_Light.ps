#version 330

#include "Shaders/Uniforms/SH_FrameUniforms.si"
#include "Shaders/Uniforms/SH_TexUniforms.si"
#include "Shaders/Utility/SH_HSV.si"
#include "Shaders/Utility/SH_Utility.si"
#include "Shaders/Utility/SH_Random.si"

// TODO: Pack these neater
uniform vec3 Position;
uniform vec3 Direction;
uniform vec3 Color;
uniform float Range;
uniform float ConeRadius;
uniform float Intensity;

// Hacks for shadow interpolation
uniform float Timestamp;
uniform vec3 ShadowPosition;
uniform vec4 ShadowRect;
uniform sampler2D TexShadow;


in vec2 TexCoord;
out vec4 Output;

float ShadowDepth(vec4 InPixelPos, vec3 InLightPos)
{
    vec3 toLight = InLightPos - InPixelPos.xyz;
    float lightDist = length(toLight);
    vec3 toLightDir = toLight / lightDist;
    float depth = SampleCubeAtlas(TexShadow, ShadowRect, toLightDir).a * Range;
    return abs(depth - lightDist);
}

float SimpleShadows(vec4 InPixelPos)
{
    float shadow = ShadowDepth(InPixelPos, ShadowPosition);
    return 1.0 - clamp(abs(shadow) - 0.5, 0, 1);
}

void main()
{
    vec4 worldPos = SampleWorldPos(TexCoord).xyzw;
    vec3 toLight = Position - worldPos.xyz;
    float lightDistSqr = SquaredLength(toLight);
    if (lightDistSqr > Range * Range)
        discard;

    float lightDist = sqrt(lightDistSqr);    
    float fade = 1 - lightDist / Range;
    fade = fade * fade; // pow2
    
    vec3 toLightDir = toLight / lightDist;
    vec3 normal = SampleNormal(TexCoord);
    float d = dot(toLightDir, normal);
    if (d < 0)
        discard;

    float shadow = 1;
    if (Timestamp != 0)
    {
        shadow = SimpleShadows(worldPos);
        if (shadow < 0.001f)
            discard;
    }
    
    float intensity = Intensity * (pow(d, 0.5)) * fade * shadow; 
    Output.rgb = Color * (1.0 + intensity * 0.2);
    Output.a = intensity;
}
