#include "Shaders/Uniforms/SH_FrameUniforms.si"
#include "Shaders/Uniforms/SH_TexUniforms.si"
#include "Shaders/Utility/SH_Utility.si"
#include "Shaders/Utility/SH_DeferredID.si"

#include "Shaders/Lights/SH_Shadows.si"
#include "Shaders/Lights/SH_SSShadows.si"
#include "Shaders/PBR/SH_PBR_Light.si"

const int MAX_LIGHTS = 10;
const bool SCREEN_SPACE_SHADOWS = false;

uniform vec4 Positions[MAX_LIGHTS]; // + ranges
uniform vec4 Directions[MAX_LIGHTS]; // + cones
uniform vec4 Colors[MAX_LIGHTS]; // + intensity

uniform vec4 ShadowPositions[MAX_LIGHTS]; // + timestamps
uniform vec4 ShadowRects[MAX_LIGHTS];

uniform sampler2D TexShadow;
uniform vec2 FaceTexel;
uniform int Lights;

in vec2 TexCoord;
layout (location = 0) out vec4 Output;

float Godrays(vec4 InWorldPos, vec3 InToLight)
{
    return 0.0f;
}

void main()
{
    Output = vec4(0.0f);
    
    vec3 worldPos = SampleWorldPos(TexCoord).xyz;
    vec3 normal = SampleNormal(TexCoord);
    vec4 albedo = SampleAlbedo(TexCoord);
    vec3 surface = SampleSurface(TexCoord);
    
    for (int i = 0; i < Lights; i++)
    {   
        vec3 position = Positions[i].xyz;
        vec3 toLight = position - worldPos;
        float lightDistSqr = SquaredLength(toLight);
        
        float range = Positions[i].w;
        if (lightDistSqr > range * range)
            continue;
        
        float lightDist = sqrt(lightDistSqr);
        vec3 toLightDir = toLight / lightDist;
        float d = dot(toLightDir, normal);
        if (d < -0.1f)
            continue;
        
        vec3 shadowPos = ShadowPositions[i].xyz;
        vec4 shadowRect = ShadowRects[i];
        vec3 toLightShadow = shadowPos - worldPos;
        float shadow = Shadow(toLightShadow, TexShadow, TexCoord, FaceTexel, shadowRect, range);
        shadow *= surface.b; // AO
        if (shadow < 0.001f)
            continue;
        
        if (SCREEN_SPACE_SHADOWS)
        {
            shadow = min(shadow, ScreenSpaceShadow(worldPos, position));
            if (shadow < 0.001f)
                continue;
        }
        
        vec3 color = Colors[i].xyz * Colors[i].w * 10.0f;
        vec3 light = PBRLight(worldPos, normal, albedo.rgb, surface, position, color, range);
        
        Output.rgb += light * (1.0f - albedo.a);
        Output.a = 1.0f;
    }
}
