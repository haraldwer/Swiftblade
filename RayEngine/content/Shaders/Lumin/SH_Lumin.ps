#version 330

#include "Shaders/Uniforms/SH_FrameUniforms.si"
#include "Shaders/Uniforms/SH_TexUniforms.si"
#include "Shaders/Utility/SH_HSV.si"
#include "Shaders/Utility/SH_CubeSampling.si"
#include "Shaders/Utility/SH_Utility.si"
#include "Shaders/Utility/SH_Random.si"

uniform float Timestamp;
uniform vec3 ProbePosition;
uniform vec3 ProbeRange;
uniform vec4 ProbeRect;
uniform sampler2D TexLumin;

in vec2 TexCoord;
out vec4 Output;

const float DIST_BIAS = 5.0f;

void main()
{
    // TODO: Sample both ambient light and reflections!

    vec3 worldPos = SampleWorldPos(TexCoord).xyz;
    vec3 pixelToProbe = worldPos - ProbePosition;
    float pixelToProbeDist = length(pixelToProbe);
    vec3 pixelToProbeDir = pixelToProbe / pixelToProbeDist; 
    
    // Is surface in view of probe?
    float maxRange = max(max(ProbeRange.x, ProbeRange.y), ProbeRange.z);
    float depth = SampleCubeAtlas(TexLumin, ProbeRect, pixelToProbeDir).a * maxRange;
    float depthDiff = depth - pixelToProbeDist;
    float depthFade = 1.0;//clamp(DIST_BIAS - max(-depthDiff, 0), 0, 1);
    if (depthFade < 0.001)
        discard;
    
    // Is surface pointing towards probe?
    vec3 normal = SampleNormal(TexCoord);
    float surfaceDot = -dot(normalize(pixelToProbe), normal);
    if (surfaceDot < -0.1f)
        discard;
    
    // Distance fade
    vec3 range = abs(pixelToProbe) / ProbeRange;
    float dist = max(max(range.x, range.y), range.z);
    float giFade = min(1.0f, 4.0f - dist * 4.0f);
    if (giFade < 0.001)
        discard;
    
    // Use luminance for now, later expect irradiance map
    vec3 color = SampleCubeAtlas(TexLumin, ProbeRect, -normal).rgb;
    vec3 hsv = rgb2hsv(color);
    float lum = min(1, hsv.z) * 0.5;
    float factor = lum * surfaceDot * giFade * depthFade; 
    
    Output.rgb = hsv2rgb(vec3(hsv.xy, 1.0));
    Output.a = factor;
}