
#include "Shaders/Uniforms/SH_FrameUniforms.si"
#include "Shaders/Utility/SH_CubeSampling.si"
#include "Shaders/Utility/SH_Utility.si"

const int LAYERS = 1;
const int LAYER_PROBES = 64;
const int PROBE_COUNT = (LAYERS * LAYER_PROBES) + 1;
const int GRID_COUNT = 1024; 

uniform sampler2D TexBRDF;
uniform sampler2D TexIrradiance;
uniform sampler2D TexPrefilter;

uniform vec2 FaceTexel;
uniform vec2 RectSize;

// Layer data
uniform vec3 Densities[LAYERS];
uniform ivec4 Sizes[LAYERS];
uniform ivec4 Starts[LAYERS];

// Probe data
uniform int Indices[GRID_COUNT]; // Map grid -> probe
uniform vec4 Positions[PROBE_COUNT];
uniform vec2 Rects[PROBE_COUNT];

const int PROBE_SAMPLES = 6;

struct ProbeData
{
    int index[PROBE_SAMPLES * LAYERS];
    float weight[PROBE_SAMPLES * LAYERS];
};

float ProbeOcclusion(vec3 InWorldPos, vec3 InNormal, vec3 InProbePos)
{
    vec3 pixelToProbe = InWorldPos - InProbePos;
    float pixelToProbeDist = length(pixelToProbe);
    vec3 pixelToProbeDir = pixelToProbe / pixelToProbeDist;
    
    // Is surface pointing towards probe?
    float surfaceDot = -dot(pixelToProbeDir, InNormal);
    if (surfaceDot < -0.1)
        return 0.0;
    
    return 1 / (pixelToProbeDist + 0.001);
}

ProbeData GetProbe(vec3 InWorldPos, vec3 InNormal)
{
    // Convert position to grid
    // Find probe, use fallback
    // Possibly sample multiple probes?
    ProbeData data;
    for (int layer = 0; layer < LAYERS; layer++)
    {
        vec3 density = Densities[layer];
        ivec3 size = Sizes[layer].xyz;
        ivec3 start = Starts[layer].xyz;
        int startIndex = Sizes[layer].w;
        int endIndex = Starts[layer].w;
        
        // Round to all directions
        vec3 posCeil = ceil(InWorldPos * density);
        ivec3 gridPosCeil = ivec3(posCeil) - start;
        vec3 posFloor = floor(InWorldPos * density);
        ivec3 gridPosFloor = ivec3(posFloor) - start;
        vec3 posRound = round(InWorldPos * density);
        ivec3 gridPosRound = ivec3(posRound) - start;
        
        // Grid positions to test
        ivec3 positions[PROBE_SAMPLES] = ivec3[PROBE_SAMPLES](
            ivec3(gridPosRound.xy, gridPosCeil.z),
            ivec3(gridPosRound.xy, gridPosFloor.z),
            ivec3(gridPosRound.x, gridPosCeil.y, gridPosRound.z),
            ivec3(gridPosRound.x, gridPosFloor.y, gridPosRound.z),
            ivec3(gridPosCeil.x, gridPosRound.yz),
            ivec3(gridPosFloor.x, gridPosRound.yz)
        );
        
        for (int posIndex = 0; posIndex < PROBE_SAMPLES; posIndex++)
        {
            int dataIndex = posIndex + layer * PROBE_SAMPLES;
            
            // Map to grid index
            ivec3 gridPos = positions[posIndex];
            int index = gridPos.x + gridPos.y * size.x + gridPos.z * size.x * size.y;
            
            // Map index to probe
            int probeIndex = Indices[index + startIndex] + 1;
            vec3 probePos = Positions[probeIndex].xyz; 
            float weight = ProbeOcclusion(InWorldPos, InNormal, probePos);
            if (probeIndex == 0)
                weight = 0.1; 
            if (weight < 0.01)
                probeIndex = 0;
            data.index[dataIndex] = probeIndex;
            data.weight[dataIndex] = weight; 
        }
    }
    
    return data;
}

vec2 SampleBRDF(vec3 InN, vec3 InV, float InRoughness)
{
    return texture(TexBRDF, vec2(max(dot(InN, InV), 0), InRoughness)).rg;
}

vec3 ProbeSample(sampler2D InTex, ProbeData InProbe, vec3 InDir, int InMip)
{
    vec4 c = vec4(0);
    for (int i = 0; i < PROBE_SAMPLES * LAYERS; i++)
    {
        int index = InProbe.index[i];
        float weight = InProbe.weight[i];
        vec2 rectPos = Rects[index];
        vec4 rect = vec4(rectPos, RectSize);
        vec3 color = SampleCubeAtlasMip(TexIrradiance, FaceTexel, rect, InDir, InMip).rgb;
        c.rgb += color * weight;
        c.a += weight;
    }
    return c.rgb / c.a;
}

vec3 SampleIrradiance(ProbeData InProbe, vec3 InDir)
{
    return ProbeSample(TexIrradiance, InProbe, InDir, 0);
}

vec3 SamplePrefilter(ProbeData InProbe, vec3 InDir, int InMip)
{
    return ProbeSample(TexPrefilter, InProbe, InDir, InMip);
}
