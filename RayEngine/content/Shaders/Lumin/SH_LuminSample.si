
#include "Shaders/Uniforms/SH_FrameUniforms.si"
#include "Shaders/Utility/SH_CubeSampling.si"
#include "Shaders/Utility/SH_Utility.si"

const int LAYERS = 1;
const int LAYER_PROBES = 256 - 64 - 1;
const int PROBE_COUNT = (LAYERS * LAYER_PROBES) + 1;
const int GRID_COUNT = 512; 

uniform sampler2D TexBRDF;
uniform sampler2D TexIrradiance;
uniform sampler2D TexPrefilter;

uniform vec2 FaceTexel;
uniform vec2 RectSize;

// Layer data
uniform vec3 Densities[LAYERS];
uniform ivec4 Sizes[LAYERS];
uniform ivec4 Starts[LAYERS];

// Probe data
uniform int Indices[GRID_COUNT]; // Map grid -> probe
uniform vec4 Positions[PROBE_COUNT];
uniform vec2 Rects[PROBE_COUNT];

const int PROBE_SAMPLES = 8;

struct ProbeData
{
    int index[PROBE_SAMPLES * LAYERS];
    float weight[PROBE_SAMPLES * LAYERS];
};

float ProbeOcclusion(vec3 InWorldPos, vec3 InNormal, vec3 InProbePos, vec3 InDensity)
{
    vec3 pixelToProbe = InWorldPos - InProbePos;
    float pixelToProbeDist = length(pixelToProbe);
    vec3 pixelToProbeDir = pixelToProbe / pixelToProbeDist;
    
    // Is surface pointing towards probe?
    float surfaceDot = -dot(pixelToProbeDir, InNormal);
    float occluded = Pow2(Saturate(surfaceDot));
    
    vec3 denseDist = abs(pixelToProbe) * InDensity;
    float maxDist = max(max(denseDist.x, denseDist.y), denseDist.z);
    occluded *= Saturate(1 - maxDist);
    
    return occluded;
}

ProbeData GetProbe(vec3 InWorldPos, vec3 InNormal)
{
    // Convert position to grid
    // Find probe, use fallback
    // Possibly sample multiple probes?
    ProbeData data;
    
    for (int layer = 0; layer < LAYERS; layer++)
    {
        vec3 density = Densities[layer];
        ivec3 size = Sizes[layer].xyz;
        ivec3 start = Starts[layer].xyz;
        int startIndex = Sizes[layer].w;
        int endIndex = Starts[layer].w;
        
        // Push pixelpos towards normal
        vec3 pixelPos = InWorldPos + (InNormal / density) * 0.1f;  
        
        // Round to all directions
        vec3 posCeil = ceil(pixelPos * density);
        ivec3 gridPosCeil = ivec3(posCeil) - start;
        vec3 posFloor = floor(pixelPos * density);
        ivec3 gridPosFloor = ivec3(posFloor) - start;
        
        // Grid positions to test
        ivec3 positions[PROBE_SAMPLES] = ivec3[PROBE_SAMPLES](
            ivec3(gridPosCeil.x, gridPosCeil.y, gridPosCeil.z),
            ivec3(gridPosFloor.x, gridPosCeil.y, gridPosCeil.z),
            ivec3(gridPosCeil.x, gridPosFloor.y, gridPosCeil.z),
            ivec3(gridPosFloor.x, gridPosFloor.y, gridPosCeil.z),
            ivec3(gridPosCeil.x, gridPosCeil.y, gridPosFloor.z),
            ivec3(gridPosFloor.x, gridPosCeil.y, gridPosFloor.z),
            ivec3(gridPosCeil.x, gridPosFloor.y, gridPosFloor.z),
            ivec3(gridPosFloor.x, gridPosFloor.y, gridPosFloor.z)
        );
        
        for (int posIndex = 0; posIndex < PROBE_SAMPLES; posIndex++)
        {
            int dataIndex = posIndex + layer * PROBE_SAMPLES;
            
            // Map to grid index
            ivec3 gridPos = positions[posIndex];
            int index = gridPos.x + gridPos.y * size.x + gridPos.z * size.x * size.y + startIndex;
            
            int probeIndex = 0;
            float weight = 0.0001f;
            
            // Map index to probe
            if (index < endIndex)
            {
                int testProbeIndex = Indices[index + startIndex] + 1;
                vec3 testProbePos = Positions[testProbeIndex].xyz; 
                float testWeight = ProbeOcclusion(pixelPos, InNormal, testProbePos, density);
                if (testWeight > 0.0001f)
                {
                    probeIndex = testProbeIndex;
                    weight = testWeight;
                }
            }
            
            data.index[dataIndex] = probeIndex;
            data.weight[dataIndex] = weight; 
        }
    }
    
    return data;
}

vec2 SampleBRDF(vec3 InN, vec3 InV, float InRoughness)
{
    return texture(TexBRDF, vec2(max(dot(InN, InV), 0), InRoughness)).rg;
}

vec3 ProbeSample(sampler2D InTex, ProbeData InProbe, vec3 InDir, int InMip)
{
    vec4 c = vec4(0);
    for (int i = 0; i < PROBE_SAMPLES * LAYERS; i++)
    {
        int index = InProbe.index[i];
        float weight = InProbe.weight[i];
        vec2 rectPos = Rects[index];
        vec4 rect = vec4(rectPos, RectSize);
        vec3 color = SampleCubeAtlasMip(InTex, FaceTexel, rect, InDir, InMip).rgb;
        c.rgb += color * weight;
        c.a += weight;
    }
    return c.rgb / c.a;
}

vec3 SampleIrradiance(ProbeData InProbe, vec3 InDir)
{
    return ProbeSample(TexIrradiance, InProbe, InDir, 0);
}

vec3 SamplePrefilter(ProbeData InProbe, vec3 InDir, int InMip)
{
    return ProbeSample(TexPrefilter, InProbe, InDir, InMip);
}
