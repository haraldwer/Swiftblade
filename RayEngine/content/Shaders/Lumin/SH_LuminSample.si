
#include "Shaders/Uniforms/SH_FrameUniforms.si"
#include "Shaders/Utility/SH_CubeSampling.si"
#include "Shaders/Utility/SH_Utility.si"

const int LAYERS = 1;
const int LAYER_PROBES = 18 * 18 * 1 - 64 - 1;
const int PROBE_COUNT = (LAYERS * LAYER_PROBES) + 1;
const int GRID_COUNT = 512;

const float PROBE_NORMAL_OFFSET = 0.1f;
const float PROBE_DEPTH_FADE_DIST = 0.8f;
const float PROBE_DEPTH_FADE_BIAS = 0.2f;

uniform sampler2D TexBRDF;
uniform sampler2D TexIrradiance;
uniform sampler2D TexPrefilter;

uniform vec2 ProbeFaceTexel;
uniform vec2 ProbeRectSize;
uniform vec2 ProbeNearFar;
uniform vec3 ProbeOffset;

// Layer data
uniform vec3 ProbeDensities[LAYERS];
uniform ivec4 ProbeSizes[LAYERS];
uniform ivec4 ProbeStarts[LAYERS];

// Probe data
uniform int ProbeIndices[GRID_COUNT]; // Map grid -> probe
uniform vec4 ProbePositions[PROBE_COUNT];
uniform vec2 ProbeRects[PROBE_COUNT];

const int PROBE_SAMPLES = 8;
const int PROBE_DATA_SIZE = PROBE_SAMPLES * LAYERS + 1;
const float PROBE_FALLBACK_WEIGHT = 0.000000001;

struct ProbeData
{
    int index[PROBE_DATA_SIZE];
    float weight[PROBE_DATA_SIZE];
};

float ProbeOcclusion(vec3 InWorldPos, vec3 InNormal, vec4 InProbePos, vec3 InDensity, int InRectIndex)
{
    vec3 pixelToProbe = InWorldPos - InProbePos.xyz;
    float pixelToProbeDist = length(pixelToProbe);
    vec3 pixelToProbeDir = pixelToProbe / pixelToProbeDist;
    
    // Is surface pointing towards probe?
    float surfaceDot = -dot(pixelToProbeDir, InNormal);
    float occluded = Pow2(Saturate(surfaceDot));
    
    vec3 denseDist = abs(pixelToProbe) * InDensity;
    float maxDist = max(max(denseDist.x, denseDist.y), denseDist.z);
    occluded *= Saturate(1 - maxDist);
    
    //if (occluded > 0.00001)
    //{
    //    // Is surface in view of probe?
    //    vec4 rect = vec4(ProbeRects[InRectIndex], ProbeRectSize);
    //    float probeDepth = SampleCubeAtlas(TexIrradiance, ProbeFaceTexel, rect, pixelToProbeDir).a;
    //    probeDepth *= ProbeNearFar.y;
    //    
    //    float depthDiff = probeDepth - pixelToProbeDist;
    //    float depthDiffBias = max(-depthDiff - PROBE_DEPTH_FADE_BIAS, 0);
    //    float depthDiffScaled = depthDiffBias / PROBE_DEPTH_FADE_DIST;
    //    occluded *= Saturate(1 - depthDiffScaled);
    //}

    float time = InProbePos.w * 0.1f;
    occluded *= Pow2(Pow2(Saturate(time)));
    
    return occluded;
}

ProbeData GetProbe(vec3 InWorldPos, vec3 InNormal)
{
    // Convert position to grid
    // Find probe, use fallback
    // Possibly sample multiple probes?
    ProbeData data;
    float totalWeight = 0;
    
    for (int layer = 0; layer < LAYERS; layer++)
    {
        vec3 density = ProbeDensities[layer];
        ivec3 size = ProbeSizes[layer].xyz;
        int startIndex = ProbeSizes[layer].w;
        ivec3 start = ProbeStarts[layer].xyz;
        int endIndex = ProbeStarts[layer].w;
        
        // Push pixelpos towards normal
        vec3 pixelPos = InWorldPos + (InNormal * PROBE_NORMAL_OFFSET);  
        
        // Round to all directions
        vec3 posCeil = ceil(pixelPos * density - ProbeOffset);
        ivec3 gridPosCeil = ivec3(posCeil) - start;
        vec3 posFloor = floor(pixelPos * density - ProbeOffset);
        ivec3 gridPosFloor = ivec3(posFloor) - start;
        
        // Grid positions to test
        ivec3 positions[PROBE_SAMPLES] = ivec3[PROBE_SAMPLES](
            ivec3(gridPosCeil.x, gridPosCeil.y, gridPosCeil.z),
            ivec3(gridPosFloor.x, gridPosCeil.y, gridPosCeil.z),
            ivec3(gridPosCeil.x, gridPosFloor.y, gridPosCeil.z),
            ivec3(gridPosFloor.x, gridPosFloor.y, gridPosCeil.z),
            ivec3(gridPosCeil.x, gridPosCeil.y, gridPosFloor.z),
            ivec3(gridPosFloor.x, gridPosCeil.y, gridPosFloor.z),
            ivec3(gridPosCeil.x, gridPosFloor.y, gridPosFloor.z),
            ivec3(gridPosFloor.x, gridPosFloor.y, gridPosFloor.z)
        );
        
        for (int posIndex = 0; posIndex < PROBE_SAMPLES; posIndex++)
        {
            int dataIndex = posIndex + layer * PROBE_SAMPLES;
            
            // Map to grid index
            ivec3 gridPos = positions[posIndex];
            int index = gridPos.x + gridPos.y * size.x + gridPos.z * size.x * size.y + startIndex;
            
            // Map index to probe
            if (index < endIndex)
            {
                int testProbeIndex = ProbeIndices[index + startIndex] + 1;
                vec4 testProbePos = ProbePositions[testProbeIndex];
                float testWeight = ProbeOcclusion(pixelPos, InNormal, testProbePos, density, testProbeIndex);
                data.index[dataIndex] = testProbeIndex;
                data.weight[dataIndex] = testWeight; 
                totalWeight += testWeight;
            }
            else
            {
                data.index[dataIndex] = 0;
                data.weight[dataIndex] = 0;
            }
        }
    }
    
    data.index[PROBE_DATA_SIZE - 1] = 0;
    data.weight[PROBE_DATA_SIZE - 1] = max(0, PROBE_FALLBACK_WEIGHT - totalWeight); // Fallback
    
    return data;
}

vec2 SampleBRDF(vec3 InN, vec3 InV, float InRoughness)
{
    return texture(TexBRDF, vec2(max(dot(InN, InV), 0), InRoughness)).rg;
}

vec3 ProbeSample(sampler2D InTex, ProbeData InProbe, vec3 InDir, int InMip)
{
    vec4 c = vec4(0);
    for (int i = 0; i < PROBE_DATA_SIZE; i++)
    {
        int index = InProbe.index[i];
        float weight = InProbe.weight[i];
        vec2 rectPos = ProbeRects[index];
        vec4 rect = vec4(rectPos, ProbeRectSize);
        vec3 color = SampleCubeAtlasMip(InTex, ProbeFaceTexel, rect, InDir, InMip).rgb;
        c.rgb += color * weight;
        c.a += weight;
    }
    return c.rgb / c.a;
}

vec3 SampleIrradiance(ProbeData InProbe, vec3 InDir)
{
    return ProbeSample(TexIrradiance, InProbe, InDir, 0);
}

vec3 SamplePrefilter(ProbeData InProbe, vec3 InDir, int InMip)
{
    return ProbeSample(TexPrefilter, InProbe, InDir, InMip);
}
