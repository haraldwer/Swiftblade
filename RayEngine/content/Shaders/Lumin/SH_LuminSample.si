
#include "Shaders/Uniforms/SH_FrameUniforms.si"
#include "Shaders/Utility/SH_CubeSampling.si"
#include "Shaders/Utility/SH_Utility.si"

// Main switch
#define LUMIN
//#define LUMIN_DEPTH_OCCLUSION

const int LAYERS = 2;
const int LAYER_COUNT = 15 * 15;
const int PROBE_COUNT = (LAYERS * LAYER_COUNT) + 1;
const int GRID_COUNT = 1024;

const float LUMIN_STRENGTH = 0.5f;
const float PROBE_NORMAL_OFFSET = 0.1f;
const float PROBE_DEPTH_FADE_DIST = 1.0f;
const float PROBE_DEPTH_FADE_BIAS = 1.0f;

uniform sampler2D TexBRDF;
uniform sampler2D TexIrradiance;
uniform sampler2D TexPrefilter;

uniform vec2 ProbeFaceTexel;
uniform vec2 ProbeRectSize;
uniform vec2 ProbeNearFar;
uniform vec3 ProbeOffset;

// Layer data
uniform vec3 ProbeDensities[LAYERS];
uniform ivec4 ProbeSizes[LAYERS];
uniform ivec4 ProbeStarts[LAYERS];

// Probe data
uniform int ProbeIndices[GRID_COUNT]; // Map grid -> probe
uniform vec4 ProbePositions[PROBE_COUNT];
uniform vec2 ProbeRects[PROBE_COUNT];

const int PROBE_SAMPLES = 8;
const int PROBE_DATA_SIZE = PROBE_SAMPLES * LAYERS;

struct ProbeData
{
    int index[PROBE_DATA_SIZE];
    float weight[PROBE_DATA_SIZE];
};

vec3 ProbeSample(sampler2D InTex, ProbeData InProbe, vec3 InDir, int InMip)
{
#ifdef LUMIN
    
    vec3 c = vec3(0.0f);
    float totalWeight = 0.0f;
    for (int i = 0; i < PROBE_DATA_SIZE; i++)
    {
        int index = InProbe.index[i];
        float weight = InProbe.weight[i];
        vec2 rectPos = ProbeRects[index];
        vec4 rect = vec4(rectPos, ProbeRectSize);
        vec3 color = SampleCubeAtlasMip(InTex, ProbeFaceTexel, rect, InDir, InMip).rgb;

        // Blend the probes!
        c += color * weight;
        totalWeight += weight;
    }
    
    // Fill using fallback
    vec2 fallbackRectPos = ProbeRects[0];
    vec4 fallbackRect = vec4(fallbackRectPos, ProbeRectSize);
    vec3 fallback = SampleCubeAtlasMip(InTex, ProbeFaceTexel, fallbackRect, InDir, InMip).rgb;
    float fallbackWeight = max(LUMIN_STRENGTH, 1.0f - totalWeight);
    c += fallback * fallbackWeight;
    totalWeight += fallbackWeight;
    
    return c / max(1.0f, totalWeight);
    
#else
    
    vec2 rectPos = ProbeRects[0];
    vec4 rect = vec4(rectPos, ProbeRectSize);
    return SampleCubeAtlasMip(InTex, ProbeFaceTexel, rect, InDir, InMip).rgb;
    
#endif 
}

float ProbeDotFade(float InSurfaceToProbeDot)
{
    return Saturate(InSurfaceToProbeDot + 0.5f); 
}

float ProbeDistanceFade(vec3 InPixelToProbe, vec3 InNormal, vec3 InDensity)
{
    vec3 scaled = InPixelToProbe * InDensity;
    
    // Somehow use normal to not account for some directions
    //vec3 normal = abs(InNormal);
    //scaled.x *= max(normal.y, normal.z);
    //scaled.y *= max(normal.x, normal.z);
    //scaled.z *= max(normal.x, normal.y);
    
    float dist = max(max(abs(scaled.x), abs(scaled.y)), abs(scaled.z));
    return Saturate(1.0f - dist);
}

float ProbeTimeFade(float InTime)
{
    return Saturate(InTime * 1.0f);
}

float ProbeOcclusion(vec3 InWorldPos, vec3 InNormal, vec4 InProbePos, vec3 InDensity, int InRectIndex)
{
    float weight = 1.0f;
    
    vec3 pixelToProbe = InWorldPos - InProbePos.xyz;
    float pixelToProbeDist = max(0.01f, length(pixelToProbe));
    vec3 pixelToProbeDir = pixelToProbe / pixelToProbeDist;
    
    float surfaceDot = -dot(pixelToProbeDir, InNormal);
    weight *= ProbeDotFade(surfaceDot);
    weight *= ProbeDistanceFade(pixelToProbe, InNormal, InDensity);
    weight *= ProbeTimeFade(InProbePos.w);
    
#ifdef LUMIN_DEPTH_OCCLUSION
    
    if (weight > 0.0f)
    {
        // Is surface in view of probe?
        vec4 rect = vec4(ProbeRects[InRectIndex], ProbeRectSize);
        float irradianceDepth = SampleCubeAtlas(TexIrradiance, ProbeFaceTexel, rect, pixelToProbeDir).a;
        float prefilterDepth = SampleCubeAtlas(TexPrefilter, ProbeFaceTexel, rect, pixelToProbeDir).a;
        float probeDepth = min(irradianceDepth, prefilterDepth);
        probeDepth *= ProbeNearFar.y;
        
        float depthDiff = probeDepth - pixelToProbeDist;
        float depthDiffBias = max(abs(depthDiff) - PROBE_DEPTH_FADE_BIAS, 0.0f);
        float depthDiffScaled = depthDiffBias / PROBE_DEPTH_FADE_DIST;
        weight *= Saturate(1.0f - depthDiffScaled);
    }
    
#endif
    
    return weight;
}

ProbeData GetProbe(vec3 InWorldPos, vec3 InNormal)
{
    ProbeData data;
    
#ifdef LUMIN
    
    for (int layer = 0; layer < LAYERS; layer++)
    {
        vec3 density = ProbeDensities[layer];
        ivec3 size = ProbeSizes[layer].xyz;
        int startIndex = ProbeSizes[layer].w;
        ivec3 start = ProbeStarts[layer].xyz;
        int endIndex = ProbeStarts[layer].w;
        
        // Push pixelpos towards normal
        vec3 pixelPos = InWorldPos + (InNormal * PROBE_NORMAL_OFFSET);  
        
        // Round to all directions
        vec3 posCeil = ceil(pixelPos * density - ProbeOffset);
        ivec3 gridPosCeil = ivec3(posCeil) - start;
        vec3 posFloor = floor(pixelPos * density - ProbeOffset);
        ivec3 gridPosFloor = ivec3(posFloor) - start;
        
        // Grid positions to test
        ivec3 positions[PROBE_SAMPLES] = ivec3[PROBE_SAMPLES](
            ivec3(gridPosCeil.x, gridPosCeil.y, gridPosCeil.z),
            ivec3(gridPosFloor.x, gridPosCeil.y, gridPosCeil.z),
            ivec3(gridPosCeil.x, gridPosFloor.y, gridPosCeil.z),
            ivec3(gridPosFloor.x, gridPosFloor.y, gridPosCeil.z),
            ivec3(gridPosCeil.x, gridPosCeil.y, gridPosFloor.z),
            ivec3(gridPosFloor.x, gridPosCeil.y, gridPosFloor.z),
            ivec3(gridPosCeil.x, gridPosFloor.y, gridPosFloor.z),
            ivec3(gridPosFloor.x, gridPosFloor.y, gridPosFloor.z)
        );
        
        for (int posIndex = 0; posIndex < PROBE_SAMPLES; posIndex++)
        {
            int dataIndex = posIndex + layer * PROBE_SAMPLES;
            
            // Map to grid index
            ivec3 gridPos = positions[posIndex];
            int index = gridPos.x + gridPos.y * size.x + gridPos.z * size.x * size.y + startIndex;
            
            // Map index to probe
            if (index < endIndex)
            {
                int testProbeIndex = ProbeIndices[index] + 1;
                vec4 testProbePos = ProbePositions[testProbeIndex];
                float testWeight = ProbeOcclusion(pixelPos, InNormal, testProbePos, density, testProbeIndex);
                data.index[dataIndex] = testProbeIndex;
                data.weight[dataIndex] = testWeight;
            }
            else
            {
                data.index[dataIndex] = 0;
                data.weight[dataIndex] = 0.0f;
            }
        }
    }
    
#endif
    
    return data;
}

vec2 SampleBRDF(vec3 InN, vec3 InV, float InRoughness)
{
    return texture(TexBRDF, vec2(max(dot(InN, InV), 0.0f), InRoughness)).rg;
}

vec3 SampleIrradiance(ProbeData InProbe, vec3 InDir)
{
    return ProbeSample(TexIrradiance, InProbe, InDir, 0);
}

vec3 SamplePrefilter(ProbeData InProbe, vec3 InDir, int InMip)
{
    return ProbeSample(TexPrefilter, InProbe, InDir, InMip);
}
