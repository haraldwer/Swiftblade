#version 330

#include "Shaders/SH_FrameUniforms.si"
#include "Shaders/SH_TextureUniforms.si"
#include "Shaders/SH_Random.si"
#include "Shaders/SH_Utility.si"

in vec2 TexCoord;
out vec4 Output;

const int ITERATIONS = 16;
const float INTENSITY = 1.0f;
const float RADIUS = 0.5f;
const float SAMPLE_DISTANCE_SCALE = 0.5f;
const float SAMPLE_DISTANCE_BIAS = 0.05f;
const float SAMPLE_NORMAL_BIAS = 0.1f;
const float NEAR_START_FADE = 1.0;
const float NEAR_END_FADE = 2.5;

const float POSITION_THRESHOLD = 1.0;
const float DEPTH_THRESHOLD = 1.0;
const float INCREASE_LERP = 1.0;
const float DECREASE_LERP = 10.0;

vec3 SSAOPosition(vec2 uv)
{
     return texture(TexPosition, uv).xyz;
}

float SSAODepth(vec2 uv)
{
     return texture(TexScreenPosition, uv).z;
}

vec3 SSAONormal(vec2 uv)
{
     return texture(TexNormal, uv).xyz;
}

float SSAOIteration(vec2 InCoord, vec2 InOffset, vec3 InStartPosition, vec3 InStartNormal, float InStartDepth)
{
     vec2 coord = clamp(InCoord + InOffset, 0.0001, 0.9999);
     
     // Depth test
     float depth = SSAODepth(coord);
     if (InStartDepth < depth || depth < NEAR_START_FADE)
          return 0.0;
     
     vec3 diff = SSAOPosition(coord) - InStartPosition;

     // Position
     float distance = length(diff);
     float distPart = (1.0f / (1.0f + distance)) * SAMPLE_DISTANCE_SCALE;
     distPart *= clamp((distance / SAMPLE_DISTANCE_BIAS) - SAMPLE_DISTANCE_BIAS, 0.0, 1.0);
     
     // Normal
     vec3 direction = diff / distance;
     float normalDot = clamp(dot(InStartNormal, direction) - SAMPLE_NORMAL_BIAS, 0.0, 1.0);

     // Distance fade
     float fade = clamp((depth - NEAR_START_FADE) / (NEAR_END_FADE - NEAR_START_FADE), 0.0, 1.0);
     
     return clamp(normalDot * distPart * fade, 0.0, 1.0);
}

float SSAO()
{
     vec3 startPosition = SSAOPosition(TexCoord);
     vec3 startNormal = SSAONormal(TexCoord);
     float startDepth = texture(TexScreenPosition, TexCoord).z;
     
     float inv = 1.0f / ITERATIONS;
     float rStep = inv * RADIUS / startDepth;
     
     float ao = 0.0f;
     float radius = 0.0f;
     for (int j = 0; j < ITERATIONS; ++j)
     {
          radius += rStep;
          vec2 uv = (Random2(TexCoord + radius + Time) - 0.5) * 2.0;
          ao += SSAOIteration(TexCoord, uv * radius, startPosition, startNormal, startDepth); 
     }
     float finalAO = clamp(ao * INTENSITY * inv, 0.0, 1.0);
     return finalAO;
}

void main()
{
     float ssao = SSAO();
     
     float prev = 0.0;
     vec3 currPos = texture(TexPosition, TexCoord).xyz;
     float currDepth = texture(TexScreenPosition, TexCoord).z;
     vec2 prevCoord = GetPreviousScreenCoord(currPos, NearFar.x);
     if (prevCoord.x > 0.0 && prevCoord.x < 1.0 && 
         prevCoord.y > 0.0 && prevCoord.y < 1.0)
     {
          float prevDepth = texture(TexScreenPosition, prevCoord).z;
          if (prevDepth - currDepth < DEPTH_THRESHOLD)
          {
               vec3 prevPos = texture(TexPosition, prevCoord).xyz; 
               float diff = length(currPos - prevPos);
               if (diff < POSITION_THRESHOLD) 
                    prev = texture(TexAO, prevCoord).r;
          }
     }
     
     Output = vec4(vec3(0.0), 1.0);
     float lerp = INCREASE_LERP;
     if (ssao < prev)
          lerp = DECREASE_LERP;
     float l = clamp(lerp * Delta, 0.0f, 1.0f);
     Output.r = ssao * l + prev * (1.0f - l);
     
     // Debug output
     Output.g = prev * 100.0;
     Output.b = ssao * 100.0;
}
